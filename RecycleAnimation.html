<html>
  <head>
    <meta charset="UTF-8" />
    <title>Recycle Animation</title>
    <style>
      body {
        /* set margin to 0 and overflow to hidden, to use the complete page */
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <!-- HTML body will hold the Output -->
    <script type="module">
      import * as THREE from "./libs/three.module.js";
      import { OrbitControls } from "./libs/OrbitControls.js";
      import * as BufferGeometryUtils from "./libs/BufferGeometryUtils.js";

      let renderer = null,
        scene = null,
        camera = null,
        light = null,
        pointLightHelper = null;
      let water;

      let verts = [];

      window.onload = function init() {
        /*********************
         * SCENE
         * *******************/
        // create an empty scene, that will hold all our elements such as objects, cameras and lights
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffffff);

        /*********************
         * CAMERA
         * *******************/
        // create a camera, which defines where we're looking at
        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
        camera.position.set(0, 6.5, 19);

        /*********************
         * RENDERER
         * *******************/
        // create a render and set the size
        renderer = new THREE.WebGLRenderer({ antialias: false }); // aliasing (jagged edges when rendering)
        renderer.setSize(window.innerWidth, window.innerHeight);

        // add the output of the renderer to an HTML element (this case, the body)
        document.body.appendChild(renderer.domElement);

        /*********************
         * CONTROLS
         *********************/
        const controls = new OrbitControls(camera, renderer.domElement);

        // Add lights
        light = new THREE.PointLight(0xaaaaaa);
        light.position.set(0, 6, 8);
        scene.add(light);

        pointLightHelper = new THREE.PointLightHelper(light, 1);
        scene.add(pointLightHelper);

        let ambient = new THREE.AmbientLight(0x888888);
        scene.add(ambient);

        const textureLoader = new THREE.TextureLoader();

        // TEXTURAS DA AREIA
        const sandBasecolor = textureLoader.load(
          "./textures/Sand/Sand_004_COLOR.png"
        );
        const sandNormalMap = textureLoader.load(
          "./textures/Sand/Sand_004_Normal.png"
        );
        const SandHeightMap = textureLoader.load(
          "./textures/Sand/Sand_004_Height.png"
        );
        const SandRoughnessMap = textureLoader.load(
          "./textures/Sand/Sand_004_ROUGH.png"
        );
        const SandMetalnessMap = textureLoader.load(
          "./textures/Sand/Sand_004_OCC.png"
        );

        // TEXTURAS DA AGUA
        const waterBasecolor = textureLoader.load(
          "./textures/Water/Water_002_COLOR.jpg"
        );
        const waterNormalMap = textureLoader.load(
          "./textures/Water/Water_002_NORM.jpg"
        );
        const waterHeightMap = textureLoader.load(
          "./textures/Water/Water_002_DISP.png"
        );
        const waterRoughnessMap = textureLoader.load(
          "./textures/Water/Water_002_ROUGH.jpg"
        );
        const waterMetalnessMap = textureLoader.load(
          "./textures/Water/Water_002_OCC.jpg"
        );

        // TEXTURAS DA PEDRA
        const rockBasecolor = textureLoader.load(
          "./textures/Rocks/Pebbles_025_BaseColor.jpg"
        );
        const rockNormalMap = textureLoader.load(
          "./textures/Rocks/Pebbles_025_Normal.jpg"
        );
        const rockHeightMap = textureLoader.load(
          "./textures/Rocks/Pebbles_025_Height.png"
        );
        const rockRoughnessMap = textureLoader.load(
          "./textures/Rocks/Pebbles_025_Roughness.jpg"
        );
        const rockMetalnessMap = textureLoader.load(
          "./textures/Rocks/Pebbles_025_AmbientOcclusion.jpg"
        );

        /*********************
         * SAND PLANE
         *********************/

        const plane = new THREE.Mesh(
          new THREE.PlaneGeometry(30, 30, 512, 512),
          new THREE.MeshStandardMaterial({
            map: sandBasecolor,
            normalMap: sandNormalMap,
            displacementMap: SandHeightMap,
            displacementScale: 0.7,
          })
        );
        plane.material.side = THREE.DoubleSide;
        plane.position.y = 0.45;
        plane.position.x = 0;
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);

      /*   const plane2 = new THREE.Mesh(
          new THREE.PlaneGeometry(15, 0.3, 512, 512),
          new THREE.MeshStandardMaterial({
            map: sandBasecolor,
            normalMap: sandNormalMap,
            displacementMap: SandHeightMap,
            displacementScale: 0.1,
          })
        );
        plane2.material.side = THREE.DoubleSide;
        plane2.position.y = 0.95;
        plane2.position.x = 0;
        plane2.position.z = 7.41;
        scene.add(plane2);

        const plane3 = new THREE.Mesh(
          new THREE.PlaneGeometry(15, 0.3, 512, 512),
          new THREE.MeshStandardMaterial({
            map: sandBasecolor,
            normalMap: sandNormalMap,
            displacementMap: SandHeightMap,
            displacementScale: 0.1,
          })
        );
        plane3.material.side = THREE.DoubleSide;
        plane3.position.y = 0.95;
        plane3.position.x = 7.56;
        plane3.rotation.y = -Math.PI / 2;
        scene.add(plane3);

        const plane4 = new THREE.Mesh(
          new THREE.PlaneGeometry(15, 0.3, 512, 512),
          new THREE.MeshStandardMaterial({
            map: sandBasecolor,
            normalMap: sandNormalMap,
            displacementMap: SandHeightMap,
            displacementScale: 0.1,
          })
        );
        plane4.material.side = THREE.DoubleSide;
        plane4.position.y = 0.95;
        plane4.position.x = -7.4;
        plane4.rotation.y = -Math.PI / 2;
        scene.add(plane4);

        const plane5 = new THREE.Mesh(
          new THREE.PlaneGeometry(15, 0.3, 512, 512),
          new THREE.MeshStandardMaterial({
            map: sandBasecolor,
            normalMap: sandNormalMap,
            displacementMap: SandHeightMap,
            displacementScale: 0.1,
          })
        );
        plane5.material.side = THREE.DoubleSide;
        plane5.position.y = 0.95;
        plane5.position.x = 0;
        plane5.position.z = -7.57;
        scene.add(plane5); */

        /*********************
         * PLANO DA AGUA
         * *******************/
        const geometries = [];

        let tuft1 = new THREE.PlaneGeometry(120, 120, 8, 8);
        tuft1.translate(0, 0, 0);
        2;
        geometries.push(tuft1);

        const waterGeometry =
          BufferGeometryUtils.mergeBufferGeometries(geometries);
        water = new THREE.Mesh(
          waterGeometry,
          new THREE.MeshStandardMaterial({
            map: waterBasecolor,
            normalMap: waterNormalMap,
            displacementMap: waterHeightMap,
            roughnessMap: waterRoughnessMap,
            metalnessMap: waterMetalnessMap,
            displacementScale: 0.5,
          })
        );
        water.position.y = 0;
        water.position.x = 0;
        water.position.z = 0;
        water.rotation.x = -Math.PI / 2;
        scene.add(water);

        // SAVE initial vertices coordinates and settings for their circular motion
        for (let i = 0; i < water.geometry.attributes.position.count; i++) {
          verts.push({
            x: water.geometry.attributes.position.getX(i),
            y: water.geometry.attributes.position.getY(i),

            ang: Math.random() * Math.PI * 2, // initial angle
            amp: -0.6 + Math.random() * 0.2, // radius
            speed: 0.02 + Math.random() * 0.02, // angular velocity
          });
        }
        console.log(verts);

        const geometries_pebbles = [];

        const rocks1 = new THREE.SphereGeometry(1.5, 64, 64);
        rocks1.translate(-2, 0, 0);
        jitter(rocks1, 0.05);
        geometries_pebbles.push(rocks1);

        const PebblesGeometry =
          BufferGeometryUtils.mergeBufferGeometries(geometries_pebbles);
        const pebbles = new THREE.Mesh(
          PebblesGeometry,
          new THREE.MeshStandardMaterial({
            map: rockBasecolor,
            normalMap: rockNormalMap,
            displacementMap: rockHeightMap,
            roughnessMap: rockRoughnessMap,
            metalnessMap: rockMetalnessMap,
            displacementScale: 0.1,
          })
        );
        pebbles.position.x = 7;
        pebbles.rotation.x = -Math.PI / 2;
        scene.add(pebbles);

        // Run the run loop
        renderer.setAnimationLoop(render);
      };

      function render() {
        // move the light, harmonically
        light.position.x = 2 * Math.sin(Date.now() / 1000);
        pointLightHelper.update();

        // for all vertices of the water mesh
        for (let i = 0; i < water.geometry.attributes.position.count; i++) {
          let vprops = verts[i]; // get INITIAL vertices and movement definitions
          // update X and Y values according to a 2D circular motion
          let currentXposition = vprops.x + Math.cos(vprops.ang) * vprops.amp;
          let currentYposition = vprops.y + Math.sin(vprops.ang) * vprops.amp;
          vprops.ang += vprops.speed; // update angle for next frame
          // set new X and Y coordinates for the vertex at the given index i
          water.geometry.attributes.position.setXY(
            i,
            currentXposition,
            currentYposition
          );
        }
        // mandatory so that the new position values are rendered again
        water.geometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
      }

      function jitter(geo, maxRandomDist) {
        for (let i = 0; i < geo.attributes.position.count; i++) {
          // get X, Y and X values for the vertex coordinates at the given index i
          let currentXposition = geo.attributes.position.getX(i);
          let currentYposition = geo.attributes.position.getY(i);
          let currentZposition = geo.attributes.position.getZ(i);
          // alter coordinates by a random value
          currentXposition += 2 * maxRandomDist * Math.random() - maxRandomDist;
          currentYposition += 2 * maxRandomDist * Math.random() - maxRandomDist;
          currentZposition += 2 * maxRandomDist * Math.random() - maxRandomDist;
          // set new values for X, Y and X coordinates for the vertex at the given index i
          geo.attributes.position.setXYZ(
            i,
            currentXposition,
            currentYposition,
            currentZposition
          );
        }
      }
    </script>
  </body>
</html>
